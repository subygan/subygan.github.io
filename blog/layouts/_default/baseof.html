<!DOCTYPE html>
<html lang="{{ .Site.LanguageCode }}">
{{ partial "header.html" . }}

<!-- Inline script to restore sidebar state BEFORE body renders to minimize flash -->
<script>
(function() {
  const EXPANDED_KEY = 'sidebar-expanded-sections';
  const stored = sessionStorage.getItem(EXPANDED_KEY);
  if (stored) {
    const expandedSections = JSON.parse(stored);
    // Create style element to pre-expand sections (will be removed after JS takes over)
    const style = document.createElement('style');
    style.id = 'sidebar-init-styles';
    let css = '';
    expandedSections.forEach(function(section) {
      css += '.sidebar-nav-arrow[data-section="' + section.replace(/"/g, '\\"') + '"] { opacity: 1; }\n';
      css += '.sidebar-nav-arrow[data-section="' + section.replace(/"/g, '\\"') + '"] svg { transform: rotate(90deg); }\n';
      css += '.sidebar-nav-submenu[data-parent="' + section.replace(/"/g, '\\"') + '"] { max-height: 5000px; margin-top: 0.25rem; }\n';
    });
    style.textContent = css;
    document.head.appendChild(style);
  }
})();
</script>

<body class="suriya-blog">
  <!-- Progress bar -->
  <div id="progress-bar"></div>

  <!-- Top navigation -->
  {{ partial "navigation.html" . }}

  <!-- Dark mode toggle -->
  <button id="darkModeBtn" class="theme-toggle" aria-label="Toggle dark mode" title="Toggle dark mode">
    <svg id="lightIcon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <svg id="darkIcon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </button>

  <!-- Mobile menu toggle -->
  <button class="menu-toggle" id="menu-toggle" aria-label="Toggle menu">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </button>

  <!-- Main layout -->
  <div class="blog-layout">
    <!-- Left sidebar -->
    <aside class="sidebar" id="sidebar">
      {{ partial "sidebar.html" . }}
    </aside>

    <!-- Main content -->
    <main class="content-area">
      {{ block "main" . }}{{ end }}
    </main>

    <!-- Right TOC (only on article pages) -->
    {{ if and (eq .Kind "page") (ne .Type "page") }}
      {{ partial "article-toc.html" . }}
    {{ end }}
  </div>

  <!-- Back to top button -->
  <button id="topBtn" title="Go to top" aria-label="Back to top">â†‘</button>

  <!-- JavaScript -->
  <script>
    // Initialize dark mode immediately to prevent flash
    (function() {
      if (localStorage.getItem('darkMode') === 'enabled') {
        document.documentElement.classList.add('dark-mode');
      }
    })();

    // Dark mode toggle
    function toggleDarkMode() {
      document.documentElement.classList.toggle('dark-mode');
      const darkModeEnabled = document.documentElement.classList.contains('dark-mode');
      localStorage.setItem('darkMode', darkModeEnabled ? 'enabled' : 'disabled');
      updateDarkModeIcon();
    }

    function updateDarkModeIcon() {
      const isDark = document.documentElement.classList.contains('dark-mode');
      document.getElementById('lightIcon').style.display = isDark ? 'block' : 'none';
      document.getElementById('darkIcon').style.display = isDark ? 'none' : 'block';
    }

    document.getElementById('darkModeBtn').addEventListener('click', toggleDarkMode);
    updateDarkModeIcon();

    // Sidebar toggle for mobile
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const menuToggle = document.getElementById('menu-toggle');
      sidebar.classList.toggle('open');
      menuToggle.classList.toggle('open');
    }

    document.getElementById('menu-toggle').addEventListener('click', toggleSidebar);

    // Close sidebar when clicking outside on mobile
    document.addEventListener('click', function(event) {
      const sidebar = document.getElementById('sidebar');
      const menuToggle = document.getElementById('menu-toggle');
      if (window.innerWidth <= 768 &&
          !sidebar.contains(event.target) &&
          !menuToggle.contains(event.target) &&
          sidebar.classList.contains('open')) {
        sidebar.classList.remove('open');
        menuToggle.classList.remove('open');
      }
    });

    // Progress bar
    window.addEventListener('scroll', function() {
      const docHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
      const scrollPosition = (window.scrollY / docHeight) * 100;
      document.getElementById('progress-bar').style.width = scrollPosition + '%';

      // Show/hide back to top button
      const topBtn = document.getElementById('topBtn');
      if (window.scrollY > 300) {
        topBtn.style.display = 'block';
      } else {
        topBtn.style.display = 'none';
      }
    });

    // Back to top button
    document.getElementById('topBtn').addEventListener('click', function() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });

    // Notion-style recursive collapsible sidebar navigation
    document.addEventListener('DOMContentLoaded', function() {
      // Remove the inline init styles now that JS has taken over
      const initStyles = document.getElementById('sidebar-init-styles');
      if (initStyles) {
        initStyles.remove();
      }

      // Store expanded state in sessionStorage to persist during navigation
      const EXPANDED_KEY = 'sidebar-expanded-sections';

      function getExpandedSections() {
        const stored = sessionStorage.getItem(EXPANDED_KEY);
        return stored ? JSON.parse(stored) : [];
      }

      function saveExpandedSections(sections) {
        sessionStorage.setItem(EXPANDED_KEY, JSON.stringify(sections));
      }

      function toggleSection(arrow, submenu, sectionPath) {
        // Check both arrow and submenu to be safe
        const isExpanded = arrow.classList.contains('expanded') || submenu.classList.contains('expanded');
        const expandedSections = getExpandedSections();

        if (isExpanded) {
          // Collapse
          arrow.classList.remove('expanded');
          submenu.classList.remove('expanded');
          // Remove from storage
          const index = expandedSections.indexOf(sectionPath);
          if (index > -1) {
            expandedSections.splice(index, 1);
          }
        } else {
          // Expand
          arrow.classList.add('expanded');
          submenu.classList.add('expanded');
          // Add to storage
          if (!expandedSections.includes(sectionPath)) {
            expandedSections.push(sectionPath);
          }
        }

        saveExpandedSections(expandedSections);
      }

      // Handle arrow clicks (toggle expand/collapse)
      const arrows = document.querySelectorAll('.sidebar-nav-arrow');
      arrows.forEach(function(arrow) {
        arrow.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();

          const wrapper = this.closest('.sidebar-nav-link-wrapper');
          const submenu = wrapper.nextElementSibling;
          const sectionPath = this.getAttribute('data-section');

          if (submenu && submenu.classList.contains('sidebar-nav-submenu')) {
            toggleSection(arrow, submenu, sectionPath);
          }
        });
      });

      // Restore expanded state from storage (classes added by inline script in head)
      const expandedSections = getExpandedSections();
      arrows.forEach(function(arrow) {
        const sectionPath = arrow.getAttribute('data-section');
        if (expandedSections.includes(sectionPath)) {
          arrow.classList.add('expanded');
          const wrapper = arrow.closest('.sidebar-nav-link-wrapper');
          const submenu = wrapper.nextElementSibling;
          if (submenu && submenu.classList.contains('sidebar-nav-submenu')) {
            submenu.classList.add('expanded');
          }
        }
      });

      // Auto-expand and highlight current section (walk up the tree)
      const currentPath = window.location.pathname;
      const allSidebarLinks = document.querySelectorAll('.sidebar-nav a[data-path]');

      allSidebarLinks.forEach(function(link) {
        const linkPath = link.getAttribute('data-path');

        // Check if this is the current page
        if (linkPath === currentPath) {
          link.classList.add('active');

          // Walk up the tree to expand all parent sections
          let parent = link.closest('.sidebar-nav-submenu');
          while (parent) {
            parent.classList.add('expanded');

            // Find the arrow for this submenu
            const parentPath = parent.getAttribute('data-parent');
            if (parentPath) {
              const parentArrow = document.querySelector('.sidebar-nav-arrow[data-section="' + parentPath + '"]');
              if (parentArrow) {
                parentArrow.classList.add('expanded');

                // Save to storage
                const expandedSections = getExpandedSections();
                if (!expandedSections.includes(parentPath)) {
                  expandedSections.push(parentPath);
                  saveExpandedSections(expandedSections);
                }
              }
            }

            // Move up to the next level
            parent = parent.parentElement.closest('.sidebar-nav-submenu');
          }
        }
      });

      // TOC scroll tracking
      const tocLinks = document.querySelectorAll('.toc-item a');
      if (tocLinks.length > 0) {
        const headings = Array.from(document.querySelectorAll('#write h2, #write h3, #write h4'))
          .filter(h => h.id);

        function updateTOC() {
          let current = '';
          headings.forEach(heading => {
            const rect = heading.getBoundingClientRect();
            if (rect.top <= 100) {
              current = heading.id;
            }
          });

          tocLinks.forEach(link => {
            link.classList.remove('active');
            if (link.getAttribute('href') === '#' + current) {
              link.classList.add('active');
            }
          });
        }

        window.addEventListener('scroll', updateTOC);
        updateTOC();
      }
    });
  </script>
</body>
</html>
